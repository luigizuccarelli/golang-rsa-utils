In our recent hackathon in Baltimore (see here) one of our challenges was to use blockchain to ensure data privacy and also ensure payment transactions for backend systems were encrypted and secure.

This led me to play around with the blockchain concepts. So just a quick side note, one of the guys on our team mentioned this is not a great use case for blockchain, we are not mining, we are not using a peer-to-peer netowrk for consensus,
or proff of work and statemtn of work , it makes no sense to use it, at first I looked at it and had to agree, but re-thinking the solution to our problem I really think there is a use case. Here's why

(reade the full article here https://medium.com/hashreader/the-case-for-your-internal-blockchain-strategy-c1217254c5c4)
TLDR; In Summary ( I have not done this justice) so please read the article.

Blockchain versus database
- Why not just store heavily encrypted data in  a database. Well if I have admin access and can change audits and data, its a no brainer, blockchain is immutable and tamper proof its a distributed ledger system.

Analysing internal corporate blockchain strategy
- Speed
- Security
- Privacy and Access
- Cost Benefit Analysis

So here is my proposed internal blockchain solution.
We can set up variuos blockchain "buckets" for payments, orders, etc

We have a simple blockchain microservice (I built an initial POC using golang) and deployed it on Openshift (read more about Openshift here - It's really enterprise Kubernetes)
The important part is the utility microservice that has an emedded key pair (private,public) in the container with 0600 persmission settings. This misroservice then is the API interface for users to push data to the blockchain

The service has the following encryption floe :  (see diagram A)
- Generate a random AES-CFB key
- Sign the AES key with the senders private key
- Encrypt the data with the AES key
- Encrypt the AES key with the Receiver's public key

The data is then pushed to the blockchain with the previous and next hashes being updated accordinlgy (the block chain microservice starts with a "genesis" hash)

The only way the data can be encrypted is to have both the server's public key and the client's public and private key , making the whole process verys difficult to decrypt.
Even if the keys are compromised the blockachain cannot be changes or tampered with.

So the main problem is how do we distribute the public keys (remember we never reveal or exppose our private keys, these remain on the server/machine when created and locked down with tight permissions).
The best way is to use QKD (quantum key distribution), when we enquired about setting up a test lab the costs were in the above 180K USD. This won't work for small startups or smaller companies.

A solution I came up with was as follows. Embedd a tcp client connection (this will reside on the backend system). A tcp server will be deployed alongside the Blockchain-Insert microservice.
The blockchain-insert service has a RestFUL API point that we can send data that sets the time the tcp server should start, and also a random socket it should use.
This is initiated by the client (backend admin using a simple script). The TCP Server will start up at the given time, using the "oc command line tool" a route is exposed to allow the service to connect to the random port (we know what the port number is)
The client then connects to the tcp server and the following exchange happens. It must be noted that all tcp connectins are TLS edge terminated so all data is sent securely.

- The client reads its public key
- The client then sends the public key to the server
- The server reads and saves the client's public key
- The server reads its public key
- The server responsds to the client with its public key
- The client saves the server's public key
- The coonections are closed and won't be used until new keys are created

I have managed to get the POC working using an electron desktop application (for the client) and the server side deployed and workin on Openshift 4.3.
It's not the optimimal solution for key distribution but it does make it extremely difficult to crack.
The big win though is that we have internal blockchain buckets that hold data (with extreme security) that cannot be tampared with in any way.





